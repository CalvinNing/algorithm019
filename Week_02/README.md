
###HashMap
- HashMap 存储数据是根据键值对存储数据的，并且存储多个数据时，数据的键不能相同，如果相同该键之前对应的值将被覆盖。注意如果想要保证 HashMap 能够正确的存储数据，请确保作为键的类，已经正确覆写了 `equals()` 方法。
- HashMap 存储数据的位置与添加数据的键的 `hashCode()` 返回值有关。所以在将元素使用 HashMap 存储的时候请确保你已经按照要求重写了 `hashCode()`方法。
- HashMap 最多只允许一条存储数据的键为 null，可允许多条数据的值为 null。
- HashMap 存储数据的顺序是不确定的，并且可能会因为扩容导致元素存储位置改变。因此遍历顺序是不确定的。
- HashMap 是线程不安全的，如果需要再多线程的情况下使用可以用 `Collections.synchronizedMap(Map map)` 方法使 HashMap 具有线程安全的能力，或者使用 `ConcurrentHashMap`。
### JDK1.8 和 JDK1.7 HashMap存储数据的不同
- JDK1.7之前的存储结构
    - 「hash碰撞」时，采用「拉链法」来存储数据，新添加进来的元素总是放在数组相应的角标位置，而原来处于该角标的位置的节点作为 next 节点放到新节点的后边。
- JDK1.8中的存储结构
    - 「hash碰撞」时，不单单是使用数组加上单链表的组合了，因为如果 hash 值冲突较多的情况下，链表的长度就会越来越长，此时通过单链表来寻找 Key 对应的 Value 的时候就会使得时间复杂度达到 O(n)，因此在 JDK1.8 之后，在链表新增节点导致链表长度超过 `TREEIFY_THRESHOLD = 8` 的时候，就会在添加元素的同时将原来的单链表转化为红黑树。红黑树是一种易于增删改查的二叉树，他对与数据的查询的时间复杂度是 O(logn) 级别，所以利用红黑树的特点就可以更高效的对 HashMap 中的元素进行操作。